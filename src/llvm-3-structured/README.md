# Компилятор структурного языка, основанный на LLVM

Ранее в примере `llvm-2-compiler` был представлен компилятор, который совершает разбор и анализ формального языка, после чего генерирует промежуточный код на LLVM-IR, а затем и объектный файл с машинным кодом под ту платформу и ОС, на которой он запущен.

В данном примере добавлена генерация кода для условных операторов `if`, `if..else`, `while`, `do..while`, а механизм работы переменных адаптирован для условного выполнения.

##### Ввод
```
def main()
  x = 10
  while x < 20
    x = x + 1
    print x
  end
end
```

##### После вывода
```bash
>gcc program.o -o program
>./program
11.000000
12.000000
13.000000
14.000000
15.000000
16.000000
17.000000
18.000000
19.000000
20.000000
```

Здесь сборка идёт через `gcc`, потому что для сборки через `ld` потребуется ряд дополнительных параметров &mdash; см. [вопрос на stackoverflow.com](http://stackoverflow.com/questions/3577922/how-to-link-a-gas-assembly-program-that-uses-the-c-standard-library-with-ld-with)

### Базовые блоки в LLVM

В LLVM модуль состоит из глобальных переменных и функций. Тела функций, в свою очередь, состоят из базовых блоков. Базовый блок &mdash; это цепочка инструкций, заканчивающаяся терминальной инструкцией одной из 4-х разновидностей:

 1. возврат из функции
 2. безусловный переход в другой базовый блок
 3. условный переход в один из двух блоков.
 4. выброс исключения (в нашем языке не используется)

Терминальная инструкция не может находиться в середине блока. Код любой *условной инструкции* можно сгенерировать как цепочку базовых блоков.

При этом условная инструкция может присвоить, а может не присвоить значение какой-либо переменной, поэтому в операторе присвоения в языке с условными операторами приходится получать адрес переменной и присваивать значение ячейке с адресом. В языке ассемблера можно было бы вместо адреса использовать регистр, но в языке LLVM-IR *запрещено* создавать две инструкции присвоения для одного регистра: значение каждого регистра определяется в одной строке LLVM-IR кода.

Локальные переменные в LLVM-IR реализуются инструкциям `alloca`, `store` и `load`. 

- `alloca` выделяет память и возвращает регистр, содержащий адрес.
- `store` записывает значение одного регистра (или константы) в адрес, хранимый в другом регистре
- `load` заносит в регистр значение, хранимое в переменной, адрес которой хранится в другом регистре.

У локальных переменных есть альтернатива: инструкция `phi`. Эта инструкция выбирает одно из двух значений в зависимости от того, какой базовый блок выполнялся перед `phi`. Такой трюк подходит для реализации *условных выражений*, таких как тернарный оператор '`x ? a : b`' или логическое или с short-circuit evaluation (например, '`readFile() || reportError()`'). Трюк позволяет избежать лишних локальных переменных и сохранить значение в регистре, облегчая работу генератору машинного кода под целевую платформу.

Однако, компилятор, использующий LLVM, может не генерировать код с инструкцией `phi`, потому что внутри оптимизатора LLVM-IR есть оптимизация "mem2reg", которая сворачивает локальные переменные на стеке в регистры с применением инструкции `phi`. То есть, если вы генерируете "наивный" код с множеством локальных переменных, то в `Release` версии вы можете сделать код оптимальнее встроенными средствами LLVM, а в `Debug` версии сохранится весь поток выполнения "как есть", без пропуска инструкций.

### Изменения в сравнении с llvm-1-translator

- Класс `CVariablesScope` теперь хранит не словарь с `llvm::Value`, а словарь с `llvm::AllocaInst` (который, впрочем, унаследован от класса `llvm::Value`). Класс `llvm::AllocaInst` представляет порождённый генератором кода регистр LLVM, в котором будет хранится адрес локальной переменной. При этом адресуемая память выделена на стеке с помощью инструкции `alloca` языка LLVM-IR:
```
define i32 @main() {
entry:
  %x = alloca double
  store double 1.000000e+01, double* %x
  ; остальной код ниже
```
- В классе `CBlockCodeGenerator` метод `Visit(CAssignAST &ast)` теперь реализован иначе: сначала он ищет существующий регистр с адресом переменной по её имени, и, если регистра нет, создаёт инструкцию `alloca`. Затем создаётся инструкция `store`, которая присваивает переменной некоторое значение. Обратите внимание: инструкция `alloca` вставляется в начальном базовом блоке функции, а инструкция `store` &mdash; в текущей позиции генератора кода.
- Также реализованы методы `Visit(CWhileAst &ast)`, `Visit(CRepeatAst &ast)`, `Visit(CIfAst &ast)`: генерация кода условных инструкций выполняется с помощью базовых блоков и переходов между ними.

### Системные требования

- Рекомендуются LLVM версии 3.8, lemon произвольной версии
- Для ОС Ubuntu: установите пакеты `lemon`, `clang`, `llvm-dev`, `cmake`
- Для ОС Windows: установите CMake, [загрузите и установите Clang](http://llvm.org/releases/download.html), соберите Lemon из [исходных кодов (hwaci.com)](http://www.hwaci.com/sw/lemon/), соберите библиотеки LLVM из исходников с помощью CMake.
