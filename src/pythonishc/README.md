# Компилятор типизированного структурного языка, основанный на LLVM

Ранее в примере `llvm-3-structured` был представлен компилятор, который совершает разбор и анализ формального языка, после чего генерирует промежуточный код на LLVM-IR, а затем и объектный файл с машинным кодом под ту платформу и ОС, на которой он запущен. Уже тогда была реализована генерация кода для условных операторов `if`, `if..else`, `while`, `do..while`, и генерация кода выражений для типа `Number` (`C++ double`).

В данном примере добавлена генерация кода для различных типов данных: Boolean, Number, String. Кроме того, грамматика языка расширена объявлением этих типов данных на входах и выходах функции. При этом достаточно объявить лишь типы параметров и возвращаемого значения, а типы локальных переменных выводятся автоматически.

##### Ввод
```
function not(x Boolean) Boolean
    return x == false
end

function sqrt(x Number) Number
  if x < 0
    return 0
  end
  root = 1
  mustContinue = false
  do
    newRoot = 0.5 * (root + x / root)
    mustContinue = not(newRoot == root)
    root = newRoot
  while mustContinue end
  return root
end

function main() Number
    print "sqrt(2) = "
    print sqrt(2)
end


```

##### После вывода
```bash
>gcc program.o -o program
>./program
sqrt(2) = 
1.414214
```

Здесь сборка идёт через `gcc`, потому что для сборки через `ld` потребуется ряд дополнительных параметров &mdash; см. [вопрос на stackoverflow.com](http://stackoverflow.com/questions/3577922/how-to-link-a-gas-assembly-program-that-uses-the-c-standard-library-with-ld-with)

### Генерация кода для строк

Строки с точки зрения процессора не являются примитивными типами данных. Кроме того, они могут быть представлены разными способами. По этим причинам в языке LLVM-IR нет готового типа данных "строка", и его нужно задать самостоятельно.

Модель представления строк включает в себя две вещи: хранение и управление памятью. Есть следующие варианты хранения строк:

 1. хранить строки как `char*` &mdash; указатель на область динамической памяти, содержащую символы и завершённую нулевым символом, и использовать функции библиотеки C для обработки строк.
 2. задать структуру, содержащую поля `"size_t size"` и `"char *data"`, и задать собственные функци для обработки строк (например, написать их на языке C и скомпилировать в статическую библиотеку)

В данном примере ради простоты выбран 1-й, хотя 2-й способ более элегантен и правилен идеологически.

Есть следующие варианты управления памятью строк:

 1. Выделять память при конкатенации строк, и не удалять никогда &mdash; такой подход легко реализуется, но делает язык непригодным для использования
 2. Вынуждать программиста удалять память вручную &mdash; такой подход сильно исказит синтаксис языка и нагрузит программиста ненужными деталями
 3. Подключить внешний сборщик мусора, такой как libgc. Этот подход хорош, но всё же сборка мусора выглядит поспешным и необдуманным решением.
 4. Ввести модель, позволяющую компилятору автоматически и вовремя удалять ненужные строки.
 
В данном примере был выбран 4-й способ, чтобы показать саму возможность управления памятью со стороны компилятора с помощью семантики владения. Подобный подход реализован в нескольких промышленных языках:

- в C++ на уровне библиотеки STL в виде `unique_ptr` и `shared_ptr`
- в Rust, Objective-C и Swift на уровне самого языка (см. Automatic Reference Counting в документации Objective-C)

Модель в самом простом виде без подсчёта ссылок выглядит следующим образом:

- При сложении строк, для хранения результата создаём "связанную" строку функцией `malloc()`
- После выполнения каждой инструкции все "связанные" строки удаляются функцией `free()`, если только связанная строка не была "освобождена"
- Присваивание "связанной" строки переменной "освобождает" её, а в случае строковой константы &mdah; или строки из переменной создаёт копию строки функцией `strdup()`
- Возврат "связанной" строки из функции "освобождает" её, а в случае строковой константы &mdah; или строки из переменной создаёт копию строки функцией `strdup()`
- В каждой точке возврата функции все строки, сохранённые в переменных, освобождаются функцией `free()`

### Изменения в сравнении с llvm-3-structured

- Класс `CVariablesScope` убран, вместо него введён в строй шаблонный класс `CScopeChain<T>` из файла `Utility.h`
- Добавлен класс `CTypecheckVisitor`, совершающий проверки типов и другие семантические проверки на уровне функций и инструкций. Семантические проверки совершаются отдельным обходом AST до начала генерации кода.
- Добавлен класс `CTypeEvaluator`, совершающий расстановку и проверку типов в выражениях любой степени вложенности.
- В грамматике добавлены правила `type_reference`, `parameter_decl`, `parenthesis_parameter_list`, и вместо `std::vector<unsigned>` для хранения списка параметров используется `std::vector<CParameterDeclASTUniquePtr>`
- Добавлен новый узел AST &mdash; `CParameterDeclAST`, хранящий имя параметра функции и его тип
- Новый класс `CCodegenContext` хранит всё, что важно для кодогенерации, в том числе набор используемых функций языка C, таких как `malloc`, `free`, `printf`.

### Системные требования

- Рекомендуются LLVM версии 3.8, lemon произвольной версии
- Для ОС Ubuntu: установите пакеты `lemon`, `clang`, `llvm-dev`, `cmake`
- Для ОС Windows: установите CMake, [загрузите и установите Clang](http://llvm.org/releases/download.html), соберите Lemon из [исходных кодов (hwaci.com)](http://www.hwaci.com/sw/lemon/), соберите библиотеки LLVM из исходников с помощью CMake.
